extern "C" {
    fn nn_load_png(i32, &[u8], &mut &[u8], &mut i32, &mut i32) -> ();
}

extern fn sparse_mult_test(cnt: &Buffer, idz: &Buffer, buf: &Buffer) -> () {
    let m = make_sparse(*cnt, *idz, 2, 2);
    let n = make_matrix(*buf, 3, 3);

    print_sparse_content(m);print_string("\n");
    print_sparse_indizes(m);print_string("\n");

    print_matrix(n);print_string("\n");

    let x = sparse_mult(m, n);

    print_matrix(x);
}

extern fn create_conv_test(img: &Buffer, kernel: &Buffer) -> () {
    let m = make_matrix(*img, 16, 1);
    let k = make_matrix(*kernel, 3, 3);

    let n = make_conv_matrix(k, 4, 4, 3);

    print_sparse_content(n); print_string("\n");
    print_sparse_indizes(n); print_string("\n");

    let mut x = sparse_mult(n, m);
    x = reshape_matrix(x, 4, 4);

    print_matrix(x);
}

extern fn image_kernel_test(kernel1: &Buffer, kernel2: &Buffer, kernel3: &Buffer, img_buf: &Buffer) -> &[u8] {
    let img = make_image(*img_buf, 1920, 1111);

    let k1 = make_matrix(*kernel1, 3, 9);
    let k2 = make_matrix(*kernel2, 3, 9);
    let k3 = make_matrix(*kernel3, 3, 9);

    let c1 = conv2d(k1, 3, img);
    let c2 = conv2d(k2, 3, img);
    let c3 = conv2d(k3, 3, img);

    let mut buf = alloc(0, (img.width * img.height * 3) as i64);

    runtime_copy(0, c1.data as &[i8], 0i64, 0, buf.data, (0 * img.width * img.height) as i64, (img.width * img.height) as i64);
    runtime_copy(0, c2.data as &[i8], 0i64, 0, buf.data, (1 * img.width * img.height) as i64, (img.width * img.height) as i64);
    runtime_copy(0, c3.data as &[i8], 0i64, 0, buf.data, (2 * img.width * img.height) as i64, (img.width * img.height) as i64);

    release(c1);
    release(c2);
    release(c3);

    buf = make_interleaved(buf, 3, img.width, img.height);

    bitcast[&mut[u8]](buf.data)
}
