struct Image {
    buf : Buffer,
    width  : i32,
    height : i32
}

struct AccI {
    read  : fn(i32, i32, i32) -> u8,
    write : fn(i32, i32, i32, u8) -> ()
}

fn @make_image(buf: Buffer, width: i32, height: i32) -> Image {
    Image { buf = buf, width = width, height = height }
}

fn @get_image_acc(img: Image, channels: i32) -> AccI {
    AccI {
        read  = @|x, y, c|    { bitcast[&   [u8]](img.buf.data)((y * img.width + x) * channels + c) },
        write = @|x, y, c, v| { bitcast[&mut[u8]](img.buf.data)((y * img.width + x) * channels + c) = v; }
    }
}

// Divides all uint8 in the image to create a [0-1] float Matrix
fn @make_matrix_from_image(img: Image, buf: Buffer, off: i64) -> Matrix {
    let m = make_matrix(buf, off, MemoryFormat::HWC, 3, img.height, img.width);
    let acc_i = get_image_acc(img, 3);

    // TODO
    for acc, _val, row, col, chn in iterate_matrix(m) {
        acc.write(row, col, chn, acc_i.read(col, row, chn) as f32 / 255.0);
    }

    m
}

// Multiplies all floats in the matrix by 255 to return an 8-bit image
fn @make_image_from_matrix(m: Matrix, buf: Buffer) -> Image {
    let height = m.rows;
    let width  = m.cols;
    let img    = make_image(buf, width, height);

    let acc_m = get_mat_acc(m);

    for acc_img, _v, x, y, c in iterate_image(img, 3) {
        acc_img.write(x, y, c, (acc_m.read(y, x, c) * 255.0) as u8);
    }
    img
}

/*
// Kernel size, Channel count
fn @im2col(img: Image, ksize: i32, channels: i32, padding:i32, stride: i32) -> () {
    // TODO: Do I need this? Shouldn't I just use sparse matrices for the weights?
    // Well then I need <newlayer-depth> many matrix multiplications, like this only one would be necessary
}
*/
