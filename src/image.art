struct Image {
    buf : Buffer,
    width  : i32,
    height : i32
}

struct AccI {
    read  : fn(i32, i32, i32) -> u8,
    write : fn(i32, i32, i32, u8) -> ()
}

fn @make_image(buf: Buffer, width: i32, height: i32) -> Image {
    Image { buf = buf, width = width, height = height }
}

fn @get_image_acc(img: Image, channels: i32) -> AccI {
    AccI {
        read  = @|x, y, c|    { bitcast[&   [u8]](img.buf.data)((y * img.width + x) * channels + c) },
        write = @|x, y, c, v| { bitcast[&mut[u8]](img.buf.data)((y * img.width + x) * channels + c) = v; }
    }
}

// Divides all uint8 in the image to create a [0-1] float Matrix
fn @make_matrix_from_image(img: Image, buf: Buffer, off: i64) -> Matrix {
    let m = make_matrix(buf, off, MemoryFormat::HWC, 3, img.height, img.width);
    let acc_i = get_image_acc(img, 3);

    for acc, _val, row, col, chn in iterate_matrix_par(m) {
        acc.write(row, col, chn, acc_i.read(col, row, chn) as f32 / 255.0);
    }

    m
}

// Multiplies all floats in the matrix by 255 to return an 8-bit image
fn @make_image_from_matrix(m: Matrix, buf: Buffer) -> Image {
    let height = m.rows;
    let width  = m.cols;
    let img    = make_image(buf, width, height);

    let acc_m = get_mat_acc(m);

    for acc_img, _v, x, y, c in iterate_image(img, 3) { // Using _par here gives artifacts (because we're writing u8's?)
        acc_img.write(x, y, c, (acc_m.read(y, x, c) * 255.0) as u8);
    }
    img
}
