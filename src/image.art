struct Image {
    buf : Buffer,
    width  : i32,
    height : i32
}

struct AccI {
    read  : fn(i32, i32, i32) -> u8,
    write : fn(i32, i32, i32, u8) -> ()
}

fn @make_image(buf: Buffer, width: i32, height: i32) -> Image {
    Image { buf = buf, width = width, height = height }
}

fn @get_image_acc(img: Image, channels: i32) -> AccI {
    AccI {
        read  = @|x, y, c|    { bitcast[&   [u8]](img.buf.data)((y * img.width + x) * channels + c) },
        write = @|x, y, c, v| { bitcast[&mut[u8]](img.buf.data)((y * img.width + x) * channels + c) = v; }
    }
}

// Divides all uint8 in the image to create a [0-1] float Matrix
fn @make_matrix_from_image(img: Image, channels: i32, buf: Buffer, off: i64) -> Matrix {
    let m = make_matrix(buf, off, img.height, img.width * channels);
    let acc_m = get_mat_acc(m);

    for _a, v, x, y, c in iterate_image_par(img, channels) {
        acc_m.write(y, channels * x + c, v as f32 * (1.0 / 255.0));
    }
    m
}

// Multiplies all floats in the matrix by 255 to return an 8-bit image
fn @make_image_from_matrix(m: Matrix, channels: i32, buf: Buffer) -> Image {
    let height = m.rows;
    let width = m.cols / channels;
    let img = make_image(buf, width, height);

    let acc_m = get_mat_acc(m);

    for acc_img, _v, x, y, c in iterate_image_par(img, channels) {
        acc_img.write(x, y, c, (acc_m.read(y, channels * x+c) * 255.0) as u8);
    }
    img
}

/*
// Kernel size, Channel count
fn @im2col(img: Image, ksize: i32, channels: i32, padding:i32, stride: i32) -> () {
    // TODO: Do I need this? Shouldn't I just use sparse matrices for the weights?
    // Well then I need <newlayer-depth> many matrix multiplications, like this only one would be necessary
}
*/
