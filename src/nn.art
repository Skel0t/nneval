struct NN_SRES {
    forward : fn(Image, Buffer, Buffer) -> (),
    necess_mem : i64
}

struct NN_DEN {
    forward : fn(Image, Image, Image, Buffer, Buffer) -> (),
    necess_mem : i64
}

fn @make_sres_nn_im2col(kernels: Buffer, biases: &[f32], width: i32, height: i32) -> NN_SRES {
    // Create parameters for convolutions
    let in_channels_1  = 3;
    let out_channels_1 = 32;
    let ksize_1 = 5;
    let offset_1 = 0 as i64;

    let in_channels_2  = out_channels_1;
    let out_channels_2 = 64;
    let ksize_2 = 3;
    let offset_2 = offset_1 + (ksize_1 * ksize_1 * in_channels_1 * out_channels_1) as i64;

    let in_channels_3  = out_channels_2;
    let out_channels_3 = 64;
    let ksize_3 = 3;
    let offset_3 = offset_2 + (ksize_2 * ksize_2 * in_channels_2 * out_channels_2) as i64;

    let in_channels_4  = out_channels_3;
    let out_channels_4 = 32;
    let ksize_4 = 5;
    let offset_4 = offset_3 + (ksize_3 * ksize_3 * in_channels_3 * out_channels_3) as i64;

    let in_channels_5  = out_channels_4;
    let out_channels_5 = 32;
    let ksize_5 = 3;
    let offset_5 = offset_4 + (ksize_4 * ksize_4 * in_channels_4 * out_channels_4) as i64;

    let in_channels_6  = out_channels_5;
    let out_channels_6 = 32;
    let ksize_6 = 3;
    let offset_6 = offset_5 + (ksize_5 * ksize_5 * in_channels_5 * out_channels_5) as i64;

    let in_channels_7  = out_channels_6;
    let out_channels_7 = 3;
    let ksize_7 = 3;
    let offset_7 = offset_6 + (ksize_6 * ksize_6 * in_channels_6 * out_channels_6) as i64;

    // Kernel matrices higher order functions
    let flattened_kernels = @|i: i32| {
        match i {
            1 => make_matrix(kernels, offset_1, MemoryFormat::CHW, 1, out_channels_1, ksize_1 * ksize_1 * in_channels_1),
            2 => make_matrix(kernels, offset_2, MemoryFormat::CHW, 1, out_channels_2, ksize_2 * ksize_2 * in_channels_2),
            3 => make_matrix(kernels, offset_3, MemoryFormat::CHW, 1, out_channels_3, ksize_3 * ksize_3 * in_channels_3),
            4 => make_matrix(kernels, offset_4, MemoryFormat::CHW, 1, out_channels_4, ksize_4 * ksize_4 * in_channels_4),
            5 => make_matrix(kernels, offset_5, MemoryFormat::CHW, 1, out_channels_5, ksize_5 * ksize_5 * in_channels_5),
            6 => make_matrix(kernels, offset_6, MemoryFormat::CHW, 1, out_channels_6, ksize_6 * ksize_6 * in_channels_6),
            7 => make_matrix(kernels, offset_7, MemoryFormat::CHW, 1, out_channels_7, ksize_7 * ksize_7 * in_channels_7),
            _ => make_matrix(kernels, offset_1, MemoryFormat::CHW, 1, out_channels_1, ksize_1 * ksize_1 * in_channels_1)
        }
    };

    let biases = @|j: i32| {
        match j {
            1 => @|i: i32| { biases(i) },
            2 => @|i: i32| { biases(i + out_channels_1) },
            3 => @|i: i32| { biases(i + out_channels_1 + out_channels_2) },
            4 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3) },
            5 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4) },
            6 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5) },
            _ => @|_i:i32| { 0 as f32 }
        }
    };

    // Calculate necessary memory
    let size_nearest = (2 * width as i64) * (2 * height as i64) * in_channels_1 as i64;
    let size_im2col  = (ksize_4 as i64) * (ksize_4 as i64) * (in_channels_4 as i64) * (2 * width as i64) * (2 * height as i64);  // size for im2col matrix
    let size_img     = (2 * width as i64) * (2 * height as i64) * (out_channels_3 as i64);                                       // size to save matmul output

    fn @forward_sres(img: Image, mem: Buffer, out_buf: Buffer) -> () {
        let mut img_mat = make_matrix_from_image(img, mem, size_im2col);
        let nearest_mat = nearest(img_mat, mem, size_im2col + size_img);

        // Convolution 1
        img_mat = conv_with_im2col(ksize_1, out_channels_1, flattened_kernels(1), biases(1), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);

        print_string("conv1 done\n");

        // Convolution 2
        img_mat = conv_with_im2col(ksize_2, out_channels_2, flattened_kernels(2), biases(2), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);

        print_string("conv2 done\n");

        // Convolution 3
        img_mat = conv_with_im2col(ksize_3, out_channels_3, flattened_kernels(3), biases(3), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, 0);
        img_mat = nearest(img_mat, mem, size_im2col);

        print_string("conv3 done\n");

        // Upconvolution 1 (Conv 4)
        // Need to swap offsets now, since the upscaling/recycling before changed the order of images in memory
        img_mat = conv_with_im2col(ksize_4, out_channels_4, flattened_kernels(4), biases(4), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);

        print_string("conv4 (upconv) done\n");

        // Convolution 5
        img_mat = conv_with_im2col(ksize_5, out_channels_5, flattened_kernels(5), biases(5), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);

        print_string("conv5 done\n");

        // Convolution 6
        img_mat = conv_with_im2col(ksize_6, out_channels_6, flattened_kernels(6), biases(6), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);

        print_string("conv6 done\n");

        // Convolution 7
        img_mat = conv_with_im2col(ksize_7, out_channels_7, flattened_kernels(7), biases(7), img_mat, false, mem, 0, size_im2col);
        img_mat = chw_to_hwc(img_mat, mem, 0);

        print_string("conv7 done\n");

        // Add residual image to upscaled one
        img_mat = mkl_add_element_wise(img_mat, nearest_mat, mem, img_mat.offset);

        // Write result in output buffer
        make_image_from_matrix(img_mat, out_buf);
    }

    NN_SRES { forward = forward_sres, necess_mem = 4 * (size_nearest + size_im2col + size_img) }
}

fn @make_sres_nn_conv_mat(kernels: Buffer, biases: &[f32], width: i32, height: i32) -> NN_SRES {
    // Create parameters for convolutions
    let in_channels_1  = 3;
    let out_channels_1 = 32;
    let ksize_1 = 5;
    let offset_1 = 0 as i64;

    let in_channels_2  = out_channels_1;
    let out_channels_2 = 64;
    let ksize_2 = 3;
    let offset_2 = offset_1 + (ksize_1 * ksize_1 * in_channels_1 * out_channels_1) as i64;

    let in_channels_3  = out_channels_2;
    let out_channels_3 = 64;
    let ksize_3 = 3;
    let offset_3 = offset_2 + (ksize_2 * ksize_2 * in_channels_2 * out_channels_2) as i64;

    let in_channels_4  = out_channels_3;
    let out_channels_4 = 32;
    let ksize_4 = 5;
    let offset_4 = offset_3 + (ksize_3 * ksize_3 * in_channels_3 * out_channels_3) as i64;

    let in_channels_5  = out_channels_4;
    let out_channels_5 = 32;
    let ksize_5 = 3;
    let offset_5 = offset_4 + (ksize_4 * ksize_4 * in_channels_4 * out_channels_4) as i64;

    let in_channels_6  = out_channels_5;
    let out_channels_6 = 32;
    let ksize_6 = 3;
    let offset_6 = offset_5 + (ksize_5 * ksize_5 * in_channels_5 * out_channels_5) as i64;

    let in_channels_7  = out_channels_6;
    let out_channels_7 = 3;
    let ksize_7 = 3;
    let offset_7 = offset_6 + (ksize_6 * ksize_6 * in_channels_6 * out_channels_6) as i64;

    // Kernel matrices higher order functions
    let matrices1 = @|i: i32| { make_matrix(kernels, offset_1 + (i * ksize_1 * ksize_1 * in_channels_1) as i64, MemoryFormat::HWC, in_channels_1, ksize_1, ksize_1) };
    let matrices2 = @|i: i32| { make_matrix(kernels, offset_2 + (i * ksize_2 * ksize_2 * in_channels_2) as i64, MemoryFormat::HWC, in_channels_2, ksize_2, ksize_2) };
    let matrices3 = @|i: i32| { make_matrix(kernels, offset_3 + (i * ksize_3 * ksize_3 * in_channels_3) as i64, MemoryFormat::HWC, in_channels_3, ksize_3, ksize_3) };
    let matrices4 = @|i: i32| { make_matrix(kernels, offset_4 + (i * ksize_4 * ksize_4 * in_channels_4) as i64, MemoryFormat::HWC, in_channels_4, ksize_4, ksize_4) };
    let matrices5 = @|i: i32| { make_matrix(kernels, offset_5 + (i * ksize_5 * ksize_5 * in_channels_5) as i64, MemoryFormat::HWC, in_channels_5, ksize_5, ksize_5) };
    let matrices6 = @|i: i32| { make_matrix(kernels, offset_6 + (i * ksize_6 * ksize_6 * in_channels_6) as i64, MemoryFormat::HWC, in_channels_6, ksize_6, ksize_6) };
    let matrices7 = @|i: i32| { make_matrix(kernels, offset_7 + (i * ksize_7 * ksize_7 * in_channels_7) as i64, MemoryFormat::HWC, in_channels_7, ksize_7, ksize_7) };

    let no_bias   = @|_i:i32| { 0 as f32 };
    let biases1   = @|i: i32| { biases(i) };
    let biases2   = @|i: i32| { biases(i + out_channels_1) };
    let biases3   = @|i: i32| { biases(i + out_channels_1 + out_channels_2) };
    let biases4   = @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3) };
    let biases5   = @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4) };
    let biases6   = @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5) };

    // Calculate necessary memory
    let max_size_for_conv    = 2 as i64 * (2 * width as i64) * (2 * height as i64) * (ksize_4 * ksize_4 * in_channels_4) as i64  // sparse size
                             + (2 * width as i64) * (2 * height as i64) * out_channels_4 as i64; // sparse mult prod size
    let max_space_for_img    = (2 * width as i64) * (2 * height as i64) * out_channels_3 as i64; // space needed to save the image layer data during the forwarding
    let size_upsampled_mat   = (2 * width as i64) * (2 * height as i64) * in_channels_1 as i64;

    fn @forward_sres(img: Image, mem: Buffer, out_buf: Buffer) -> () {
        let mut img_mat = make_matrix_from_image(img, mem, max_size_for_conv);
        let nearest_mat = nearest(img_mat, mem, max_size_for_conv + max_space_for_img);

        // Convolution 1
        img_mat = conv2d(out_channels_1, matrices1, biases1, img_mat, true, mem, 0);
        img_mat = leaky_relu(img_mat, mem, max_size_for_conv);

        print_string("conv1 done\n");

        // Convolution 2
        img_mat = conv2d(out_channels_2, matrices2, biases2, img_mat, true, mem, 0);
        img_mat = leaky_relu(img_mat, mem, max_size_for_conv);

        print_string("conv2 done\n");

        // Convolution 3
        img_mat = conv2d(out_channels_3, matrices3, biases3, img_mat, true, mem, 0);
        img_mat = leaky_relu(img_mat, mem, img_mat.offset);
        img_mat = nearest(img_mat, mem, 0);

        print_string("conv3 done\n");

        // Upconvolution 1 (Conv 4)
        // Need to swap offsets now, since the upscaling/recycling before changed the order of images in memory
        img_mat = conv2d(out_channels_4, matrices4, biases4, img_mat, true, mem, max_space_for_img);
        img_mat = leaky_relu(img_mat, mem, 0);

        print_string("conv4 (upconv) done\n");

        // Convolution 5
        img_mat = conv2d(out_channels_5, matrices5, biases5, img_mat, true, mem, max_space_for_img);
        img_mat = leaky_relu(img_mat, mem, 0);

        print_string("conv5 done\n");

        // Convolution 6
        img_mat = conv2d(out_channels_6, matrices6, biases6, img_mat, true, mem, max_space_for_img);
        img_mat = leaky_relu(img_mat, mem, 0);

        print_string("conv6 done\n");

        // Convolution 7
        img_mat = conv2d(out_channels_7, matrices7, no_bias, img_mat, false, mem, max_space_for_img);
        img_mat = chw_to_hwc(img_mat, mem, 0);

        print_string("conv7 done\n");

        // Add residual image to upscaled one
        img_mat = add_element_wise(img_mat, nearest_mat, mem, img_mat.offset);

        // Write result in output buffer
        make_image_from_matrix(img_mat, out_buf);
    }

    NN_SRES { forward = forward_sres, necess_mem = 4 * (max_size_for_conv + max_space_for_img + size_upsampled_mat) }
}

fn @make_denoise_nn(kernels: Buffer, biases: &[f32], width: i32, height: i32) -> NN_DEN {
    let ksize    = 3;
    let ksize_sq = ksize * ksize;

    // ic -> ec1
    let in_channels_1  = 9;
    let out_channels_1 = 12;
    let offset_1 = 0 as i64;

    // ec1 -> ec1
    let in_channels_2  = out_channels_1;
    let out_channels_2 = 12;
    let offset_2 = offset_1 + (ksize_sq * in_channels_1 * out_channels_1) as i64;

    // ec1 -> ec2
    let in_channels_3  = out_channels_2;
    let out_channels_3 = 16;
    let offset_3 = offset_2 + (ksize_sq * in_channels_2 * out_channels_2) as i64;

    // ec2 -> ec3
    let in_channels_4  = out_channels_3;
    let out_channels_4 = 32;
    let offset_4 = offset_3 + (ksize_sq * in_channels_3 * out_channels_3) as i64;

    // ec3 -> ec4
    let in_channels_5  = out_channels_4;
    let out_channels_5 = 64;
    let offset_5 = offset_4 + (ksize_sq * in_channels_4 * out_channels_4) as i64;

    // ec4 -> ec5
    let in_channels_6  = out_channels_5;
    let out_channels_6 = 70;
    let offset_6 = offset_5 + (ksize_sq * in_channels_5 * out_channels_5) as i64;

    // ec5 -> ec5
    let in_channels_7  = out_channels_6;
    let out_channels_7 = 70;
    let offset_7 = offset_6 + (ksize_sq * in_channels_6 * out_channels_6) as i64;

    // ec5+ec3 -> dc4
    let in_channels_8  = out_channels_7 + out_channels_4;   // CROSS CONNECTION
    let out_channels_8 = 92;
    let offset_8 = offset_7 + (ksize_sq * in_channels_7 * out_channels_7) as i64;

    // dc4 -> dc4
    let in_channels_9  = out_channels_8;
    let out_channels_9 = 92;
    let offset_9= offset_8 + (ksize_sq * in_channels_8 * out_channels_8) as i64;

    // dc4+ec2 -> dc3
    let in_channels_10  = out_channels_9 + out_channels_3;  // CROSS CONNECTION
    let out_channels_10 = 70;
    let offset_10 = offset_9 + (ksize_sq * in_channels_9 * out_channels_9) as i64;

    // dc3 -> dc3
    let in_channels_11  = out_channels_10;
    let out_channels_11 = 70;
    let offset_11 = offset_10 + (ksize_sq * in_channels_10 * out_channels_10) as i64;

    // dc3+ec1 -> dc2
    let in_channels_12  = out_channels_11 + out_channels_2; // CROSS CONNECTION
    let out_channels_12 = 64;
    let offset_12 = offset_11 + (ksize_sq * in_channels_11 * out_channels_11) as i64;

    // dc2 -> dc2
    let in_channels_13  = out_channels_12;
    let out_channels_13 = 64;
    let offset_13 = offset_12 + (ksize_sq * in_channels_12 * out_channels_12) as i64;

    // dc2+ic -> dc1a
    let in_channels_14  = out_channels_13 + in_channels_1;  // CROSS CONNECTION
    let out_channels_14 = 32;
    let offset_14 = offset_13 + (ksize_sq * in_channels_13 * out_channels_13) as i64;

    // dc1a -> dc1b
    let in_channels_15  = out_channels_14;
    let out_channels_15 = 16;
    let offset_15 = offset_14 + (ksize_sq * in_channels_14 * out_channels_14) as i64;

    // dc1b -> oc
    let in_channels_16  = out_channels_15;
    let out_channels_16 = 3;
    let offset_16 = offset_15 + (ksize_sq * in_channels_15 * out_channels_15) as i64;

    // Kernel matrices higher order functions
    let flattened_kernels = @|i: i32| {
        match i {
            1  => make_matrix(kernels, offset_1,  MemoryFormat::CHW, 1, out_channels_1,  ksize_sq * in_channels_1),
            2  => make_matrix(kernels, offset_2,  MemoryFormat::CHW, 1, out_channels_2,  ksize_sq * in_channels_2),
            3  => make_matrix(kernels, offset_3,  MemoryFormat::CHW, 1, out_channels_3,  ksize_sq * in_channels_3),
            4  => make_matrix(kernels, offset_4,  MemoryFormat::CHW, 1, out_channels_4,  ksize_sq * in_channels_4),
            5  => make_matrix(kernels, offset_5,  MemoryFormat::CHW, 1, out_channels_5,  ksize_sq * in_channels_5),
            6  => make_matrix(kernels, offset_6,  MemoryFormat::CHW, 1, out_channels_6,  ksize_sq * in_channels_6),
            7  => make_matrix(kernels, offset_7,  MemoryFormat::CHW, 1, out_channels_7,  ksize_sq * in_channels_7),
            8  => make_matrix(kernels, offset_8,  MemoryFormat::CHW, 1, out_channels_8,  ksize_sq * in_channels_8),
            9  => make_matrix(kernels, offset_9,  MemoryFormat::CHW, 1, out_channels_9,  ksize_sq * in_channels_9),
            10 => make_matrix(kernels, offset_10, MemoryFormat::CHW, 1, out_channels_10, ksize_sq * in_channels_10),
            11 => make_matrix(kernels, offset_11, MemoryFormat::CHW, 1, out_channels_11, ksize_sq * in_channels_11),
            12 => make_matrix(kernels, offset_12, MemoryFormat::CHW, 1, out_channels_12, ksize_sq * in_channels_12),
            13 => make_matrix(kernels, offset_13, MemoryFormat::CHW, 1, out_channels_13, ksize_sq * in_channels_13),
            14 => make_matrix(kernels, offset_14, MemoryFormat::CHW, 1, out_channels_14, ksize_sq * in_channels_14),
            15 => make_matrix(kernels, offset_15, MemoryFormat::CHW, 1, out_channels_15, ksize_sq * in_channels_15),
            16 => make_matrix(kernels, offset_16, MemoryFormat::CHW, 1, out_channels_16, ksize_sq * in_channels_16),
            _  => make_matrix(kernels, offset_1,  MemoryFormat::CHW, 1, out_channels_1,  ksize_sq * in_channels_1)
        }
    };

    let biases = @|j: i32| {
        match j {
            1  => @|i: i32| { biases(i) },
            2  => @|i: i32| { biases(i + out_channels_1) },
            3  => @|i: i32| { biases(i + out_channels_1 + out_channels_2) },
            4  => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3) },
            5  => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4) },
            6  => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5) },
            7  => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6) },
            8  => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7) },
            9  => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8) },
            10 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8 + out_channels_9) },
            11 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8 + out_channels_9 + out_channels_10) },
            12 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8 + out_channels_9 + out_channels_10 + out_channels_11) },
            13 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8 + out_channels_9 + out_channels_10 + out_channels_11 + out_channels_12) },
            14 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8 + out_channels_9 + out_channels_10 + out_channels_11 + out_channels_12 + out_channels_13) },
            15 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8 + out_channels_9 + out_channels_10 + out_channels_11 + out_channels_12 + out_channels_13 + out_channels_14) },
            16 => @|i: i32| { biases(i + out_channels_1 + out_channels_2 + out_channels_3 + out_channels_4 + out_channels_5 + out_channels_6 + out_channels_7 + out_channels_8 + out_channels_9 + out_channels_10 + out_channels_11 + out_channels_12 + out_channels_13 + out_channels_14 + out_channels_15) },
            _  => @|_i:i32| { 0 as f32 }
        }
    };

    // Calculate necessary memory
    let size_input  = (width as i64) * (height as i64) * (in_channels_1 as i64);  // Needed for cross connection later
    let size_im2col = (width as i64) * (height as i64) * (ksize_sq as i64) * (108 /*max in channels*/ as i64);  // size for im2col matrix
    let size_img    = (width as i64) * (height as i64) * (92 /*max out channels*/ as i64);                      // size to save matmul output
    let size_pool_3 = (width as i64) * (height as i64) * (out_channels_4 as i64);    // sizes to save cross-connections
    let size_pool_2 = (width as i64) * (height as i64) * (out_channels_3 as i64);
    let size_pool_1 = (width as i64) * (height as i64) * (out_channels_2 as i64);

    let necess_mem = 4 * (size_input + size_im2col + size_img + size_pool_1 + size_pool_2 + size_pool_3);

    fn @forward_denoise(img: Image, albedo: Image, normal: Image, mem: Buffer, out_buf: Buffer) -> () {
        let mut img_mat = make_matrix_from_image(img, mem, size_im2col + size_img + 0 * size_input / 3);
        let alb_mat  = make_matrix_from_image(albedo, mem, size_im2col + size_img + 1 * size_input / 3);
        let nrm_mat  = make_matrix_from_image(normal, mem, size_im2col + size_img + 2 * size_input / 3);

        let img_acc = get_mat_acc(img_mat);
        let alb_acc = get_mat_acc(alb_mat);
        let nrm_acc = get_mat_acc(nrm_mat);

        let cat_acc = get_cat_mat_acc(get_cat_mat_acc(img_acc, alb_acc, img_mat.channels), nrm_acc, img_mat.channels + alb_mat.channels);

        // Convolution 1
        img_mat = cat_conv(ksize, out_channels_1, in_channels_1, flattened_kernels(1), biases(1), img_mat.rows, img_mat.cols, cat_acc, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);

        print_string("conv1 done\n");

        // Convolution 2
        img_mat = conv_with_im2col(ksize, out_channels_2, flattened_kernels(2), biases(2), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);
        img_mat = max_pool_2(img_mat, mem, size_im2col + size_img + size_input);    // POOL 1

        let pool_1 = get_mat_acc(img_mat);

        print_string("conv2 done\n");

        // Convolution 3
        img_mat = conv_with_im2col(ksize, out_channels_3, flattened_kernels(3), biases(3), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);
        img_mat = max_pool_2(img_mat, mem, size_im2col + size_img + size_input + size_pool_1);    // POOL 2

        let pool_2 = get_mat_acc(img_mat);

        print_string("conv3 done\n");

        // Convolution 4
        img_mat = conv_with_im2col(ksize, out_channels_4, flattened_kernels(4), biases(4), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);
        img_mat = max_pool_2(img_mat, mem, size_im2col + size_img + size_input + size_pool_1 + size_pool_2);    // POOL 3

        let pool_3 = get_mat_acc(img_mat);

        // Convolution 5
        img_mat = conv_with_im2col(ksize, out_channels_5, flattened_kernels(5), biases(5), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);
        img_mat = max_pool_2(img_mat, mem, size_im2col);

        print_string("conv5 done\n");

        // Convolution 6
        img_mat = conv_with_im2col(ksize, out_channels_6, flattened_kernels(6), biases(6), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);

        print_string("conv6 done\n");

        // Convolution 7
        img_mat = conv_with_im2col(ksize, out_channels_7, flattened_kernels(7), biases(7), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, 0);

        print_string("conv7 done\n");

        // Convolution 8
        img_mat = nearest(img_mat, mem, size_im2col);
        let cat_acc_1 = get_cat_mat_acc(get_mat_acc(img_mat), pool_3, img_mat.channels);
        img_mat = cat_conv(ksize, out_channels_8, in_channels_8, flattened_kernels(8), biases(8), img_mat.rows, img_mat.cols, cat_acc_1, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);

        print_string("conv8 done\n");

        // Convolution 9
        img_mat = conv_with_im2col(ksize, out_channels_9, flattened_kernels(9), biases(9), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, 0);

        print_string("conv9 done\n");

        // Convolution 10
        img_mat = nearest(img_mat, mem, size_im2col);
        let cat_acc_2 = get_cat_mat_acc(get_mat_acc(img_mat), pool_2, img_mat.channels);
        img_mat = cat_conv(ksize, out_channels_10, in_channels_10, flattened_kernels(10), biases(10), img_mat.rows, img_mat.cols, cat_acc_2, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);

        print_string("conv10 done\n");

        // Convolution 11
        img_mat = conv_with_im2col(ksize, out_channels_11, flattened_kernels(11), biases(11), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, 0);

        print_string("conv11 done\n");

        // Convolution 12
        img_mat = nearest(img_mat, mem, size_im2col);
        let cat_acc_3 = get_cat_mat_acc(get_mat_acc(img_mat), pool_1, img_mat.channels);
        img_mat = cat_conv(ksize, out_channels_12, in_channels_12, flattened_kernels(12), biases(12), img_mat.rows, img_mat.cols, cat_acc_3, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);

        print_string("conv12 done\n");

        // Convolution 13
        img_mat = conv_with_im2col(ksize, out_channels_13, flattened_kernels(13), biases(13), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, 0);

        print_string("conv13 done\n");

        // Convolution 14
        img_mat = nearest(img_mat, mem, size_im2col);
        let cat_acc_4 = get_cat_mat_acc(get_mat_acc(img_mat), cat_acc, img_mat.channels);
        img_mat = cat_conv(ksize, out_channels_14, in_channels_14, flattened_kernels(14), biases(14), img_mat.rows, img_mat.cols, cat_acc_4, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);

        print_string("conv14 done\n");

        // Convolution 15
        img_mat = conv_with_im2col(ksize, out_channels_15, flattened_kernels(15), biases(15), img_mat, true, mem, 0, size_im2col);
        img_mat = mkl_relu(img_mat, mem, size_im2col);

        print_string("conv15 done\n");

        // Convolution 16
        img_mat = conv_with_im2col(ksize, out_channels_16, flattened_kernels(16), biases(16), img_mat, true, mem, 0, size_im2col);

        print_string("conv16 done\n");

        // Write result in output buffer
        make_image_from_matrix(img_mat, out_buf);
    }

    NN_DEN { forward = forward_denoise, necess_mem = necess_mem }
}