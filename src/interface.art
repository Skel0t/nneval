#[export]
fn sparse_mult_test(cnt: &Buffer, idz: &Buffer, buf: &Buffer) -> () {
    // Deprecated.
    let m = make_sparse(*cnt, 0, 2, 2);
    let n = make_matrix(*buf, 0, 3, 3);

    print_sparse_content(m);print_string("\n");
    print_sparse_indizes(m);print_string("\n");

    print_matrix(n);print_string("\n");

    let x = sparse_mult(m, n);

    print_matrix(x);
}

#[export]
fn create_conv_test(img: &Buffer, kernel: &Buffer) -> () {
    let m = make_matrix(*img, 0, 16, 1);
    let k = make_matrix(*kernel, 0, 3, 3);

    let n = make_conv_matrix(k, 4, 4, 1);

    print_sparse_content(n); print_string("\n");
    print_sparse_indizes(n); print_string("\n");

    let mut x = sparse_mult(n, m);
    x = reshape_matrix(x, 4, 4);

    print_matrix(x);
}

#[export]
fn image_kernel_test(kernel1: &Buffer, kernel2: &Buffer, kernel3: &Buffer, img_buf: &Buffer) -> &[u8] {
    let img = make_image(*img_buf, 1920, 1110);

    let img_mat = make_matrix_from_image(img, 3);

    let k1 = make_matrix(*kernel1, 0, 3, 9);
    let k2 = make_matrix(*kernel2, 0, 3, 9);
    let k3 = make_matrix(*kernel3, 0, 3, 9);

    let c1 = convolute(k1, 3, img_mat, 4, 4, 0, false);
    let c2 = convolute(k2, 3, img_mat, 4, 4, 0, false);
    let c3 = convolute(k3, 3, img_mat, 4, 4, 0, false);

    let buf = alloc(0, img.width as i64 * img.height as i64 * 3 * 4);

    runtime_copy(0, bitcast[&[i8]](c1.buf.data), 0, 0, buf.data, (0 * img.width * img.height * 4) as i64, (img.width * img.height * 4) as i64);
    runtime_copy(0, bitcast[&[i8]](c2.buf.data), 0, 0, buf.data, (1 * img.width * img.height * 4) as i64, (img.width * img.height * 4) as i64);
    runtime_copy(0, bitcast[&[i8]](c3.buf.data), 0, 0, buf.data, (2 * img.width * img.height * 4) as i64, (img.width * img.height * 4) as i64);

    release(c1.buf);
    release(c2.buf);
    release(c3.buf);
    release(img_mat.buf);

    let pool_mat = max_pool(make_matrix(buf, 0, img.height, img.width * 3), 2, 3);

    let interleaved_mat = make_interleaved(pool_mat, 3);

    let upscaled_mat = nearest(interleaved_mat, 3);

    let result_img = make_image_from_matrix(upscaled_mat, 3);

    bitcast[&[u8]](result_img.buf.data)
}

#[export]
fn @sres(img_buf: &Buffer, width: i32, height: i32, out_buf: &mut Buffer, kernels: &Buffer, biases: &[f32]) -> () {
    print_i32(width);
    print_string("\t");
    print_i32(height);
    print_string("\n");

    // Why doesn't it work when i exchange 240 for width and 160 for height?
    // The above prints even print 240 160... So it should be the same, shouldn't it?
    let img = make_image(*img_buf, 240, 160);

    let forward = make_sres_nn(*kernels, biases);
    let res = forward(img);

    *out_buf = res.buf;
}

#[export]
fn offset_matrix_test(kernels: &Buffer, biases: &[f32]) -> () {
    let bc = bitcast[&mut[f32]](kernels.data);

    print_f32(bc(0)); print_string("\n");
    print_f32(bc(5 * 5 *  3 * 32)); print_string("\n");
    print_f32(bc(5 * 5 *  3 * 32 + 3 * 3 * 32 * 64)); print_string("\n");
    print_f32(bc(5 * 5 *  3 * 32 + 3 * 3 * 32 * 64 + 3 * 3 * 64 * 64)); print_string("\n");
}
