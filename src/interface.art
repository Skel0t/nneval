#[export]
fn @sres_im2col(img_buf: &Buffer, width: i32, height: i32, out_buf: &Buffer, kernels: &Buffer, biases: &[f32]) -> () {
    let img = make_image(*img_buf, width, height);

    let nn = make_sres_nn_im2col(*kernels, biases, width, height);
    let mem = alloc(0, nn.necess_mem);
    print_i64(nn.necess_mem); print_string("\n");
    nn.forward(img, mem, *out_buf);
    release(mem);
}

#[export]
fn @sres_conv_mat(img_buf: &Buffer, width: i32, height: i32, out_buf: &Buffer, kernels: &Buffer, biases: &[f32]) -> () {
    let img = make_image(*img_buf, width, height);

    let nn = make_sres_nn_conv_mat(*kernels, biases, width, height);
    let mem = alloc(0, nn.necess_mem);
    print_i64(nn.necess_mem); print_string("\n");
    nn.forward(img, mem, *out_buf);
    release(mem);
}


#[export]
fn im2col_test(img_buf: &Buffer, width: i32, height: i32, kernels: &Buffer, out_buf: &Buffer) -> () {
    let img = make_image(*img_buf, width, height);

    let mem = alloc(0, width as i64 * height as i64 * 3 * 4);

    let kernel  = make_matrix(*kernels, 0, MemoryFormat::HWC, 3, 3, 3);
    let img_mat = make_matrix_from_image(img, mem, 0);
    make_image_from_matrix(img_mat, *out_buf);

    im2col(kernel.cols, img_mat, 1, mem, 0);
}

#[export]
fn image_kernel_test(kernel: &Buffer, img_buf: &Buffer, out_buf: &Buffer) -> () {
    let height = 1110;
    let width  = 1920;
    let ksize  = 3;
    let img    = make_image(*img_buf, width, height);

    let size_img_mat     = 4 * width as i64 * height as i64 * 3;
    let size_sparse      = 2 * 4 as i64 * width as i64 * height as i64 * (ksize * ksize * 3) as i64;
    let size_conv        = 4 * width as i64 * height as i64 * 3;
    let size_interleaved = 4 * width as i64 * height as i64 * 4 * 3;
    let res_size         = 4 * width as i64 * height as i64 * 3;
    let size_nearest     = 4 * width as i64 * 2 * height as i64 * 2 * 3;

    let buffer = alloc(0, size_nearest + size_img_mat + size_conv + size_sparse + size_interleaved + res_size);

    print_string("allocated\n");

    let img_mat = make_matrix_from_image(img, buffer, 0);
    let k_mat   = make_matrix(*kernel, 0, MemoryFormat::HWC, 3, ksize, ksize);

    print_string("made matrices\n");

    convolute(k_mat, img_mat, 0, false, buffer, (size_img_mat) / 4, (size_img_mat + size_sparse) / 4);
    convolute(k_mat, img_mat, 0, false, buffer, (size_img_mat) / 4, (size_img_mat + size_sparse) / 4 + (size_conv / 3) / 4);
    convolute(k_mat, img_mat, 0, false, buffer, (size_img_mat) / 4, (size_img_mat + size_sparse) / 4 + (2 * size_conv / 3) / 4);

    print_string("made convolutions\n");

    let con_mat = make_matrix(buffer, (size_img_mat + size_sparse) / 4, MemoryFormat::CHW, 3, height, width);

    print_string("made matrix from buffers\n");

    let up_mat = nearest(con_mat, buffer, (size_img_mat + size_sparse + size_conv) / 4);

    print_string("made nearest\n");

    let res_mat = make_interleaved(up_mat, buffer, (size_img_mat + size_nearest + size_sparse + size_conv) / 4);

    print_string("made interleaved\n");

    make_image_from_matrix(res_mat, *out_buf);

    print_string("wrote output\n");

    release(buffer);
}
