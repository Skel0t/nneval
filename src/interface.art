#[import(cc = "C")] fn mkl_blas_mm_mult(_m: i32, _n: i32, _k: i32, _a: &[f32], _lda: i32, _b: &[f32], _ldb: i32, _c: &mut[f32], _ldc: i32) -> ();
#[import(cc = "C")] fn mkl_add_constant(_n: i32, _a: &[f32], _val: f32, _res: &mut[f32]) -> ();
#[import(cc = "C")] fn mkl_add_elemwise(_n: i32, _a: &[f32], _b: &[f32], _c: &mut[f32]) -> ();

#[export]
fn @sres_im2col(img_buf: &Buffer, width: i32, height: i32, out_buf: &Buffer, kernels: &Buffer, biases: &[f32]) -> () {
    let img = make_image(*img_buf, width, height);

    let nn = make_sres_nn_im2col(*kernels, biases, width, height);
    let mem = alloc(0, nn.necess_mem);
    print_i64(nn.necess_mem); print_string("\n");
    nn.forward(img, mem, *out_buf);
    release(mem);
}

#[export]
fn @sres_conv_mat(img_buf: &Buffer, width: i32, height: i32, out_buf: &Buffer, kernels: &Buffer, biases: &[f32]) -> () {
    let img = make_image(*img_buf, width, height);

    let nn = make_sres_nn_conv_mat(*kernels, biases, width, height);
    let mem = alloc(0, nn.necess_mem);
    print_i64(nn.necess_mem); print_string("\n");
    nn.forward(img, mem, *out_buf);
    release(mem);
}


#[export]
fn @im2col_test(img_buf: &Buffer, width: i32, height: i32, kernels: &Buffer, out_buf: &Buffer) -> () {
    let img = make_image(*img_buf, width, height);

    let mem = alloc(0, width as i64 * height as i64 * 3 * 4);

    let kernel  = make_matrix(*kernels, 0, MemoryFormat::HWC, 3, 3, 3);
    let img_mat = make_matrix_from_image(img, mem, 0);
    make_image_from_matrix(img_mat, *out_buf);

    im2col(kernel.cols, img_mat, 1, mem, 0);
}

#[export]
fn @image_kernel_test(kernel: &Buffer, img_buf: &Buffer, out_buf: &Buffer) -> () {
    let height = 1110;
    let width  = 1920;
    let ksize  = 3;
    let img    = make_image(*img_buf, width, height);

    let size_img_mat     = 4 * width as i64 * height as i64 * 3;
    let size_sparse      = 2 * 4 as i64 * width as i64 * height as i64 * (ksize * ksize * 3) as i64;
    let size_conv        = 4 * width as i64 * height as i64 * 3;
    let size_interleaved = 4 * width as i64 * height as i64 * 4 * 3;
    let res_size         = 4 * width as i64 * height as i64 * 3;
    let size_nearest     = 4 * width as i64 * 2 * height as i64 * 2 * 3;

    let buffer = alloc(0, size_nearest + size_img_mat + size_conv + size_sparse + size_interleaved + res_size);

    print_string("allocated\n");

    let img_mat = make_matrix_from_image(img, buffer, 0);
    let k_mat   = make_matrix(*kernel, 0, MemoryFormat::HWC, 3, ksize, ksize);

    print_string("made matrices\n");

    convolute(k_mat, img_mat, 0, false, buffer, (size_img_mat) / 4, (size_img_mat + size_sparse) / 4);
    convolute(k_mat, img_mat, 0, false, buffer, (size_img_mat) / 4, (size_img_mat + size_sparse) / 4 + (size_conv / 3) / 4);
    convolute(k_mat, img_mat, 0, false, buffer, (size_img_mat) / 4, (size_img_mat + size_sparse) / 4 + (2 * size_conv / 3) / 4);

    print_string("made convolutions\n");

    let con_mat = make_matrix(buffer, (size_img_mat + size_sparse) / 4, MemoryFormat::CHW, 3, height, width);

    print_string("made matrix from buffers\n");

    let up_mat = nearest(con_mat, buffer, (size_img_mat + size_sparse + size_conv) / 4);

    print_string("made nearest\n");

    let res_mat = make_interleaved(up_mat, buffer, (size_img_mat + size_nearest + size_sparse + size_conv) / 4);

    print_string("made interleaved\n");

    make_image_from_matrix(res_mat, *out_buf);

    print_string("wrote output\n");

    release(buffer);
}
