struct Matrix {
    buf : Buffer,
    offset : i64,
    rows : i32,
    cols : i32
}

struct Sparse { // TODO: add offset here, use only 1 Buffer
    buf : Buffer,
    offset : i64,
    rows : i32,
    cols : i32
}

// TODO: Write accessors with channels?
struct AccM {
    read  : fn(i32, i32) -> f32,
    write : fn(i32, i32, f32) -> ()
}

struct AccS {
    readC  : fn(i32, i32) -> f32,
    readI  : fn(i32, i32) -> i32,
    write : fn(i32, i32, f32, i32) -> ()
}

fn @make_matrix(buffer: Buffer, offset: i64, rows: i32, cols: i32) -> Matrix {
    Matrix { buf = buffer, offset = offset, rows = rows, cols = cols }
}

fn @reshape_matrix(m: Matrix, rows: i32, cols: i32) -> Matrix {
    if m.rows * m.cols == rows * cols {
        make_matrix(m.buf, m.offset, rows, cols)
    } else {
        m
    }
}

fn @make_sparse(buf: Buffer, offset: i64, rows: i32, cols: i32) -> Sparse {
    Sparse { buf = buf, offset = offset, rows = rows, cols = cols}
}

fn @get_sparse_acc(m: Sparse) -> AccS {
    AccS {
        readC = @|r, c|       { bitcast[&   [f32]](m.buf.data)(m.offset + (r * m.cols + c) as i64) },
        readI = @|r, c|       { bitcast[&   [i32]](m.buf.data)(m.offset + (m.cols * m.rows + r * m.cols + c) as i64) },
        write = @|r, c, v, i| { bitcast[&mut[f32]](m.buf.data)(m.offset + (r * m.cols + c) as i64) = v;
                                bitcast[&mut[i32]](m.buf.data)(m.offset + (m.cols * m.rows + r * m.cols + c) as i64) = i; }
    }
}

fn @get_mat_acc(m: Matrix) -> AccM {
    AccM {
        read  = @|r, c|    { bitcast[&   [f32]](m.buf.data)(m.offset + (r * m.cols + c) as i64) },
        write = @|r, c, v| { bitcast[&mut[f32]](m.buf.data)(m.offset + (r * m.cols + c) as i64) = v; }
    }
}

fn @matmul(a: Matrix, b: Matrix, buf: Buffer, off: i64) -> Matrix {
    let m = make_matrix(buf, off, a.rows, b.cols);
    let a_acc = get_mat_acc(a);
    let b_acc = get_mat_acc(b);

    for m_acc, _v, r, c in iterate_matrix_par(m) {
        m_acc.write(r, c, 0);
        for i in range(0, a.cols) {
            m_acc.write(r, c, m_acc.read(r, c) + a_acc.read(r, i) * b_acc.read(i, c));
        }
    }
    m
}

fn @sparse_mult(a: Sparse, b: Matrix, buf: Buffer, off: i64) -> Matrix {
    let m = make_matrix(buf, off, a.rows, b.cols);
    let b_acc = get_mat_acc(b);

    for m_acc, _v, r, c in iterate_matrix_par(m) {
        m_acc.write(r, c, 0);
        for _acc, v, i, _c in iterate_sparse_row(a, r) {
            m_acc.write(r, c, m_acc.read(r, c) + v * b_acc.read(i, c));
        }
    }
    m
}

fn @add_elem_wise(mat1: Matrix, mat2: Matrix, buf: Buffer, off: i64) -> Matrix {
    let res = make_matrix(buf, off, mat1.rows, mat1.cols);

    let res_acc  = get_mat_acc(res);
    let mat2_acc = get_mat_acc(mat2);
    for _acc, v, r, c in iterate_matrix_par(mat1) {
        res_acc.write(r, c, mat2_acc.read(r,c) + v);
    }
    res
}
